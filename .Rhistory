print("DISTANCE FROM XMAX COMPLETE")
# calculate the YDIST, which is the Y distance from every raster cell to ymax coordinate
ygrid<- subset(d2,select=c("x","y",'ydist'))
sp::coordinates(ygrid)<- c("x","y")
sp::gridded(ygrid)<-TRUE
ygrid<- raster::raster(ygrid)
ygrid<- raster::resample(ygrid,x,method="ngb")
graphics::plot(ygrid, main='Dist YMax',legend=FALSE,axes=FALSE)
raster::projection(ygrid) <- raster::crs(x)
ygrid<- raster::mask(x = ygrid, mask = x)
raster::writeRaster(ygrid,'disty.tif',overwrite = TRUE)
rm(ygrid)
print("DISTANCE FROM YMAX COMPLETE")
# now we need to generate vectors representing the 4 corners and the center of the raster
nw  <- c(x@extent@xmin,x@extent@ymax)
sw  <- c(x@extent@xmin,x@extent@ymin)
ne  <- c(x@extent@xmax,x@extent@ymax)
se  <- c(x@extent@xmax,x@extent@ymin)
mid<- c(round(x@extent@xmax - ((x@extent@xmax - x@extent@xmin)/2),0),round(x@extent@ymax - ((x@extent@ymax - x@extent@ymin)/2),0))
# generate distance to NW corner grid
NW<- raster::distanceFromPoints(x,nw)
NW<- raster::mask(x = NW, mask = x)
raster::projection(NW) <- raster::crs(x)
graphics::plot(NW, main='Dist NW',legend=FALSE,axes=FALSE)
raster::writeRaster(NW,"distnw.tif",overwrite = TRUE)
print('DISTANCE FROM NW COMPLETE')
# generate distance to SW corner grid
SW<- raster::distanceFromPoints(x,sw)
SW<- raster::mask(x = SW, mask = x)
raster::projection(SW) <- raster::crs(x)
graphics::plot(SW, main='Dist SW',legend=FALSE,axes=FALSE)
raster::writeRaster(SW,"distsw.tif",overwrite = TRUE)
print('DISTANCE FROM SW COMPLETE')
# generate distance to NE corner grid
NE<- raster::distanceFromPoints(x,ne)
NE<- raster::mask(x = NE, mask = x)
raster::projection(NE) <- raster::crs(x)
graphics::plot(NE, main='Dist from NE',legend=FALSE,axes=FALSE)
raster::writeRaster(NE,"distne.tif",overwrite = TRUE)
print('DISTANCE FROM NE COMPLETE')
# generate distance to SE corner grid
SE<- raster::distanceFromPoints(x,se)
SE<- raster::mask(x = SE, mask = x)
raster::projection(SE) <- raster::crs(x)
graphics::plot(SE, main='Dist SE',legend=FALSE,axes=FALSE)
raster::writeRaster(SE,"distse.tif",overwrite = TRUE)
print('DISTANCE FROM SE COMPLETE')
# generate distance to CENTRE grid
ctr<- raster::distanceFromPoints(x,mid)
ctr<- raster::mask(x = ctr, mask = x)
raster::projection(ctr) <- raster::crs(x)
graphics::plot(ctr, main='Dist MID',legend=FALSE,axes=FALSE)
raster::writeRaster(ctr,"distmid.tif",overwrite = TRUE)
print('DISTANCE FROM CENTRE COMPLETE')
}
oss.edf(Keene_DEM)
x<- Keene_DEM
# first we set up window and plot d
graphics::par(mfrow=c(2,4), mar=c(0.2,0.2,1.5,0.2), oma=c(0.2,0.2,2,2))
graphics::plot(x, main = "Source", legend=FALSE, axes=FALSE)
plot(x, main = "Source", legend=FALSE, axes=FALSE)
raster::plot(x, main = "Source", legend=FALSE, axes=FALSE)
devtools::check()
devtools::check()
devtools::check()
raster()
keene<- raster('C:/Users/atiko/Desktop/Keene/covariates/DEM/tif')
keene<- raster('C:/Users/atiko/Desktop/Keene/covariates/DEM.tif')
use_data(keene)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
setwd()
setwd("C:/Users/atiko/Desktop")
library(devtools)
install_github(repo = "newdale/onsoilsurvey")
setwd("C:/Users/atiko")
install.packages("raster")
library("devtools")
install_github(repo = "newdale/onsoilsurvey")
library(onsoilsurvey)
?onsoilsurvey
data(keene)
plot(keene)
raster::plot(keene)
oss.edf(keene)
library(devtools)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
observed<- c(3,7,4,9,6,2)
var(observed)
sum((observed-mean(observed))^2)/length(observed)
observed-mean(observed)
(observed-mean(observed))^2
sum(observed-mean(observed))^2
sum((observed-mean(observed))^2)
sum((observed-mean(observed))^2)/6
sum((observed-mean(observed))^2)/5
sum((observed-mean(observed))^2)/length(observed)-1
sum((observed-mean(observed))^2)/(length(observed)-1)
devtools::check()
?na.omit
devtools::check()
?trainControl
library(caret)
?trainControl
devtools::check()
devtools::check()
devtools::check()
#Create a rasterstack that will be used to intersect with sample points from field work to build models
wd=setwd("C:/Users/atiko/Desktop/Keene/covariates")
covariant.name.list <- list.files(pattern = "tif$")
CovariateStack<-stack(covariant.name.list)
library(raster)
CovariateStack<-stack(covariant.name.list)
CovariateStack
names(CovariateStack)
read.csv(OC, file = "C:/Users/atiko/Desktop/Keene/DSM/Outputs/OC.csv")
read.csv(OC, file = "C:/Users/atiko/Desktop/Keene/DSM/PH/Outputs/NEW_CODE_RESULTS/PHCACL2.csv")
read.csv(file = "C:/Users/atiko/Desktop/Keene/DSM/PH/Outputs/NEW_CODE_RESULTS/PHCACL2.csv")
OC<- read.csv(file = "C:/Users/atiko/Desktop/Keene/DSM/PH/Outputs/NEW_CODE_RESULTS/PHCACL2.csv")
##########  Add coordinates to the OC table, converts it to Spatial Points DataFrame
coordinates(OC) <- ~x + y
plot(CovariateStack, 1)
plot(OC, add = T)
plot(PCAStack, 1)
#########  Extract the covariate values from the Covariate RasterStack based on the coordinates of the sample locations,
######### then assign the class data as Factors
OC_data <- extract(CovariateStack,OC, sp = 1, method = "simple")
OC_data <- as.data.frame(OC_data)
rm(CovariateStack)
rm(OC)
View(OC_data)
dat<- OC_data[,c(3:39)]
View(dat)
colnames(dat)[1]<- "Soil_pH"
dat<- dat[,c(1,14:37)]
dat<- dat[,c(1,2,5,6,7,8,9,12:17,19)]
rm(OC_data)
keene_ph<- dat
rm(dat)
use_data(keene_ph)
setwd("C:/Users/atiko/Documents/R/dev/onsoilsurvey")
use_data(keene_ph)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
.Last.error.trace
l
devtools::check()
devtools::check()
load("C:/Users/atiko/Desktop/Keene/DSM/OC/Outputs/NEW_CODE_RESULTS/Run6/GOOF_SUMMARY.csv")
load("C:/Users/atiko/Desktop/Keene/DSM/OC/Outputs/NEW_CODE_RESULTS/Run6/CubistOC005.Rdata")
KeeneSOC<- CubistOC005
rm(CubistOC005)
use_data(KeeneSOC)
devtools::check()
KeeneSOC
varImp(KeeneSOC)
plot(KeeneSOC)
#'
#' @return data.frame
#' @export
#'
#' @examples
#' #Calculate fit statistics for the best tune model
#' data(KeeneSOC)
#' oss.goofCaret(KeeneSOC)
#'
#'
oss.goofCaret<- function(ModelName){
r<- ModelName
if(r$method=="cubist"){x<- filter(r$pred, committees==r$bestTune$committees & neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"|r$method=='parRF'){x<- filter(r$pred, mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- filter(r$pred, sigma==r$bestTune$sigma & C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- filter(r$pred,n.trees==r$bestTune$n.trees & interaction.depth==r$bestTune$interaction.depth & shrinkage==r$bestTune$shrinkage & n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- filter(r$pred, k==r$bestTune$k)
}else if (r$method=="kknn"){x<- filter(r$pred, kmax==r$bestTune$kmax & distance==r$bestTune$distance & kernel==r$bestTune$kernel)
}else {print("Not programmed for model")}
y <- x %>%
dplyr::group_by(Resample)%>%
dplyr::do(as.data.frame(oss.goof(predicted=.$pred,observed=.$obs)))
z<- as.data.frame(t(colMeans(y[c(2:7)])))
w<- as.data.frame(t(sapply(y[c(2:7)],stats::sd,na.rm=TRUE)))
z<-cbind(z,w)
rownames(z)<- r$method
colnames(z)[7:12]<- paste0("sd_",names(z[,1:6]))
rm(r,w,x,y)
invisible(as.data.frame(z))
}
oss.goofCaret(KeeneSOC)
r<- KeeneSOC
if(r$method=="cubist"){x<- filter(r$pred, committees==r$bestTune$committees & neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"|r$method=='parRF'){x<- filter(r$pred, mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- filter(r$pred, sigma==r$bestTune$sigma & C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- filter(r$pred,n.trees==r$bestTune$n.trees & interaction.depth==r$bestTune$interaction.depth & shrinkage==r$bestTune$shrinkage & n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- filter(r$pred, k==r$bestTune$k)
}else if (r$method=="kknn"){x<- filter(r$pred, kmax==r$bestTune$kmax & distance==r$bestTune$distance & kernel==r$bestTune$kernel)
}else {print("Not programmed for model")}
x<- filter(r$pred, committees==r$bestTune$committees & neighbors==r$bestTune$neighbors)
devtools::check()
data(KeeneSOC)
r<- KeeneSOC
if(r$method=="cubist"){x<- filter(r$pred, committees==r$bestTune$committees & neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"|r$method=='parRF'){x<- filter(r$pred, mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- filter(r$pred, sigma==r$bestTune$sigma & C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- filter(r$pred,n.trees==r$bestTune$n.trees & interaction.depth==r$bestTune$interaction.depth & shrinkage==r$bestTune$shrinkage & n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- filter(r$pred, k==r$bestTune$k)
}else if (r$method=="kknn"){x<- filter(r$pred, kmax==r$bestTune$kmax & distance==r$bestTune$distance & kernel==r$bestTune$kernel)
}else {print("Not programmed for model")}
library(foreign)
#install.packages("compositions")
library(compositions)
library(raster)
library(caret)
library(rgdal)
library(maptools)
library(sp)
library(gstat)
library(MASS)
library(ithir)
##set working directory for EA SPLINE of ORGANIC CARBON
wd=setwd("C:/Users/atiko/Desktop/Keene/DSM")
MyData <- read.csv(file="C:/Users/atiko/Desktop/Keene/DSM/Analytical.csv", header=TRUE, sep=",")
MyData <- read.csv(file="C:/Users/atiko/Desktop/Keene/DSM/AnalyticalNoOrg.csv", header=TRUE, sep=",")
str(MyData)
OCSpline <- ea_spline(MyData, var.name="OC",d = t(c(0,25,50,100)),lam = 0.1, vlow=0, vhigh = 100, show.progress=FALSE )
str(OCSpline)
#View(OCSpline$harmonised)
OC <- OCSpline$harmonised
##Assign the x and y coordinates to the data tables and write the tables as back up
KeeneCoords <- read.csv(file="C:/Users/atiko/Desktop/Keene/DSM/Site_Coords.csv", header=TRUE, sep=",")
##Assign the x and y coordinates to the data tables and write the tables as back up
KeeneCoords <- read.csv(file="C:/Users/atiko/Desktop/Keene/DSM/Site_CoordsNoOrg.csv", header=TRUE, sep=",")
str(KeeneCoords)
OC$x <- KeeneCoords$x
OC$y <- KeeneCoords$y
str(OC)
colnames(OC)[2] <- "OC25"
colnames(OC)[3] <- "OC50"
colnames(OC)[4] <- "OC100"
str(OC)
############Extract the covariates from the PC Stack
#Create a rasterstack that will be used to intersect with sample points from field work to build models
wd=setwd("C:/Users/atiko/Desktop/Keene/covariates")
covariant.name.list <- list.files(pattern = "tif$")
PCsStack<-stack(covariant.name.list)
PCsStack
names(PCsStack)
coordinates(OC) <- ~x + y
plot(PCsStack, 1)
plot(OC, add = T)
OC_data <- extract(PCsStack,OC, sp = 1, method = "simple")
OC_data <- as.data.frame(OC_data)
str(OC_data)
set.seed(123)
training <- sample(nrow(OC_data), 0.7*nrow(OC_data))
Training_Points <- OC_data[training, ]
covariates <- PCsStack
####paramaterize the Cubist model for OC25
fitControl <- trainControl(
method = "cv",                #Default method where all data is fit to single model with no CV
returnResamp = "all", savePredictions = 'all'            #Return all the resampling results
)
committees = c(1,10,50,100,1,10,50,100,1,10,50,100,1,10,50,100)           #Values of mtry to be tested
neighbors = c(0,0,0,0,1,1,1,1,5,5,5,5,9,9,9,9)
Cubist_tune <- data.frame(committees = committees, neighbors = neighbors)
CubistOC25 <- train(
x = Training_Points[,c(8:36)], y = Training_Points$OC25,
data = Training_Points,
method = "cubist",                  #Model of Interest - Cubist=Cubist package
tuneGrid = Cubist_tune,
trControl = fitControl)
CubistOC25
View(CubistOC25)
KeeneSOC<- CubistOC25
use_data(KeeneSOC)
use_data(KeeneSOC, overwrite=TRUE)
devtools::check()
setwd('C:/Users/atiko/Documents/R/dev/onsoilsurvey')
devtools::check()
devtools::check()
data(KeeneSOC)
oss.goofCaret(KeeneSOC)
View(KeeneSOC)
r<- KeeneSOC
if(r$method=="cubist"){x<- filter(r$pred, committees==r$bestTune$committees & neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"|r$method=='parRF'){x<- filter(r$pred, mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- filter(r$pred, sigma==r$bestTune$sigma & C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- filter(r$pred,n.trees==r$bestTune$n.trees & interaction.depth==r$bestTune$interaction.depth & shrinkage==r$bestTune$shrinkage & n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- filter(r$pred, k==r$bestTune$k)
}else if (r$method=="kknn"){x<- filter(r$pred, kmax==r$bestTune$kmax & distance==r$bestTune$distance & kernel==r$bestTune$kernel)
}else {print("Not programmed for model")}
if(r$method=="cubist"){x<- r$pred %>% filter(committees==r$bestTune$committees, neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"){x<- r$pred %>% filter(mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- r$pred %>% filter(sigma==r$bestTune$sigma, C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- r$pred %>% filter(n.trees==r$bestTune$n.trees, interaction.depth==r$bestTune$interaction.depth, shrinkage==r$bestTune$shrinkage, n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- r$pred %>% filter(k==r$bestTune$k)
}else {print("Not programmed for model")}
x<- r$pred %>% filter(committees==r$bestTune$committees, neighbors==r$bestTune$neighbors)
View(r)
r$bestTune$committees
r$bestTune$neighbors
library(dplyr)
if(r$method=="cubist"){x<- r$pred %>% filter(committees==r$bestTune$committees, neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"){x<- r$pred %>% filter(mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- r$pred %>% filter(sigma==r$bestTune$sigma, C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- r$pred %>% filter(n.trees==r$bestTune$n.trees, interaction.depth==r$bestTune$interaction.depth, shrinkage==r$bestTune$shrinkage, n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- r$pred %>% filter(k==r$bestTune$k)
}else {print("Not programmed for model")}
devtools::check()
load("C:/Users/atiko/Documents/R/dev/onsoilsurvey/data/KeeneSOC.rda")
#' @export
#'
#' @importFrom dplyr "%>%"
#'
#' @examples
#' #Calculate fit statistics for the best tune model
#' data(KeeneSOC)
#' oss.goofCaret(KeeneSOC)
#'
#'
oss.goofCaret<- function(ModelName){
r<- ModelName
if(r$method=="cubist"){x<- r$pred %>% filter(committees==r$bestTune$committees, neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"){x<- r$pred %>% filter(mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- r$pred %>% filter(sigma==r$bestTune$sigma, C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- r$pred %>% filter(n.trees==r$bestTune$n.trees, interaction.depth==r$bestTune$interaction.depth, shrinkage==r$bestTune$shrinkage, n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- r$pred %>% filter(k==r$bestTune$k)
}else {print("Not programmed for model")}
y <- x %>%
dplyr::group_by(Resample)%>%
dplyr::do(as.data.frame(oss.goof(predicted=.$pred,observed=.$obs)))
z<- as.data.frame(t(colMeans(y[c(2:7)])))
w<- as.data.frame(t(sapply(y[c(2:7)],stats::sd,na.rm=TRUE)))
z<-cbind(z,w)
rownames(z)<- r$method
colnames(z)[7:12]<- paste0("sd_",names(z[,1:6]))
rm(r,w,x,y)
invisible(as.data.frame(z))
}
oss.goofCaret(KeeneSOC)
library(dplyr)
oss.goofCaret(KeeneSOC)
library(onsoilsurvey)
oss.goofCaret(KeeneSOC)
library(devtools)
install_github(repo="newdale/onsoilsurvey")
library(devtools)
install_github(repo="newdale/onsoilsurvey")
library(onsoilsurvey)
library(dplyr)
load("C:/Users/atiko/Documents/R/dev/onsoilsurvey/data/KeeneSOC.rda")
#' @export
#'
#' @importFrom dplyr "%>%"
#'
#' @examples
#' #Calculate fit statistics for the best tune model
#' data(KeeneSOC)
#' oss.goofCaret(KeeneSOC)
#'
#'
oss.goofCaret<- function(ModelName){
r<- ModelName
if(r$method=="cubist"){x<- r$pred %>% filter(committees==r$bestTune$committees, neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"){x<- r$pred %>% filter(mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- r$pred %>% filter(sigma==r$bestTune$sigma, C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- r$pred %>% filter(n.trees==r$bestTune$n.trees, interaction.depth==r$bestTune$interaction.depth, shrinkage==r$bestTune$shrinkage, n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- r$pred %>% filter(k==r$bestTune$k)
}else {print("Not programmed for model")}
y <- x %>%
dplyr::group_by(Resample)%>%
dplyr::do(as.data.frame(oss.goof(predicted=.$pred,observed=.$obs)))
z<- as.data.frame(t(colMeans(y[c(2:7)])))
w<- as.data.frame(t(sapply(y[c(2:7)],stats::sd,na.rm=TRUE)))
z<-cbind(z,w)
rownames(z)<- r$method
colnames(z)[7:12]<- paste0("sd_",names(z[,1:6]))
rm(r,w,x,y)
invisible(as.data.frame(z))
}
oss.goofCaret(KeeneSOC)
d<- oss.goofCaret(KeeneSOC)
#' @export
#'
#' @importFrom dplyr "%>%"
#'
#' @examples
#' #Calculate fit statistics for the best tune model
#' data(KeeneSOC)
#' oss.goofCaret(KeeneSOC)
#'
#'
oss.goofCaret<- function(ModelName){
r<- ModelName
if(r$method=="cubist"){x<- r$pred %>% filter(committees==r$bestTune$committees, neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"){x<- r$pred %>% filter(mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- r$pred %>% filter(sigma==r$bestTune$sigma, C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- r$pred %>% filter(n.trees==r$bestTune$n.trees, interaction.depth==r$bestTune$interaction.depth, shrinkage==r$bestTune$shrinkage, n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- r$pred %>% filter(k==r$bestTune$k)
}else {print("Not programmed for model")}
y <- x %>%
dplyr::group_by(Resample)%>%
dplyr::do(as.data.frame(oss.goof(predicted=.$pred,observed=.$obs)))
z<- as.data.frame(t(colMeans(y[c(2:7)])))
w<- as.data.frame(t(sapply(y[c(2:7)],stats::sd,na.rm=TRUE)))
z<-cbind(z,w)
rownames(z)<- r$method
colnames(z)[7:12]<- paste0("sd_",names(z[,1:6]))
rm(r,w,x,y)
as.data.frame(z)
}
d<- oss.goofCaret(KeeneSOC)
oss.goofCaret(KeeneSOC)
#' @export
#'
#' @importFrom dplyr "%>%"
#'
#' @examples
#' #Calculate fit statistics for the best tune model
#' data(KeeneSOC)
#' oss.goofCaret(KeeneSOC)
#'
#'
oss.goofCaret<- function(ModelName){
r<- ModelName
if(r$method=="cubist"){x<- r$pred %>% filter(committees==r$bestTune$committees, neighbors==r$bestTune$neighbors)
}else if(r$method=="rf"|r$method=="qrf"){x<- r$pred %>% filter(mtry==r$bestTune$mtry)
}else if(r$method=="svmRadial"){x<- r$pred %>% filter(sigma==r$bestTune$sigma, C==r$bestTune$C)
}else if(r$method=="lm"|r$method=="lmStepAIC"){x<- r$pred
}else if(r$method=="gbm"){x<- r$pred %>% filter(n.trees==r$bestTune$n.trees, interaction.depth==r$bestTune$interaction.depth, shrinkage==r$bestTune$shrinkage, n.minobsinnode==r$bestTune$n.minobsinnode)
}else if (r$method=="knn"){x<- r$pred %>% filter(k==r$bestTune$k)
}else {print("Not programmed for model")}
y <- x %>%
dplyr::group_by(Resample)%>%
dplyr::do(as.data.frame(oss.goof(predicted=.$pred,observed=.$obs)))
z<- as.data.frame(t(colMeans(y[c(2:7)])))
w<- as.data.frame(t(sapply(y[c(2:7)],stats::sd,na.rm=TRUE)))
z<-cbind(z,w)
rownames(z)<- r$method
colnames(z)[7:12]<- paste0("sd_",names(z[,1:6]))
rm(r,w,x,y)
as.data.frame(z)
print(z)
}
d<- oss.goofCaret(KeeneSOC)
rm(d)
d<- oss.goofCaret(KeeneSOC)
KeeneSOC
devtools::check()
load("~/R/dev/onsoilsurvey/data/keene.rda")
devtools::check()
devtools::check()
data(keene)
devtools::check()
data(KeeneSOC)
oss.goofCaret(KeeneSOC)
fit1<- oss.goofCaret(KeeneSOC)
fit1
View(fit1)
devtools::check()
devtools::check()
load("~/R/dev/onsoilsurvey/data/keene.rda")
library(devtools)
install_github("newdale/onsoilsurvey")
?onsoilsurvey
??onsoilsurvey
?oss.goof
library(onsoilsurvey)
?onsoilsurvey
??onsoilsurvey
?oss/goof
?oss.goof
library(ithir)
?goof
?oss.goof
librry(devtools)
library(devtools)
devtools::check()
library(onsoilsurvey)
library(onsoilsurvey)
?oss.edf
data(keene)
oss.edf(keene)
force(keene)
library(Rcpp)
update.packages("raster")
install.packages("raster")
install.packages("raster")
install.packages("raster")
library(onsoilsurvey)
data(keene)
library(devtools)
devtools::check()
library(onsoilsurvey)
data(keene)
oss.edf(keene)
